#!/usr/bin/env ruby
##
# VBoxer
# VirtualBox Management Helper
# written by Rafael Robayna
#
# This script provides some helpful tools for using VirtualBox
# @requirements json
#
# @todo fix issue with mount
# @todo add mount display to status
##

require 'rubygems'
require 'json'

class VBoxer

	VERSION = "0.5"

	def initialize(action, box=nil, param=nil)
		conf_file = Dir.home() + '/.vboxer.json'
		begin
			File.open(conf_file, 'r') do |f|
				conf_text = ""
				f.each_line { |l| conf_text += l }
				@boxes = JSON.parse(conf_text)
			end
		rescue LoadError=>e
			puts "Error loading #{conf_file}.  #{e}"
			exit
		end

		begin
			_set_box(box)
			if action != nil && !self.respond_to?(action)
				raise "Unrecognized <command>."
			elsif action == "tunnel"
				send(action, param)
			elsif action != nil
				send(action)
			else
				help()
			end
		rescue RuntimeError=>e
			puts "Error: #{$!}"
		end
	end

	# display usage information
	def help()
		puts "version " + VERSION
		puts ""
		puts "Running VBox VMs:"
		puts %x(vboxmanage list runningvms)
		puts ""
		puts "Usage:"
		puts "vboxer <command> <box>"
		puts ""
		puts "Commands:"
		puts "start			start a virtual machine"
		puts "stop			stop a virtual machine"
		puts "ssh			ssh into a virtual machine"
		puts "mount				mount a vm directory"
		puts "umount			unmount a vm directory"
		puts "tunnel			tunnel a port locally"
		puts "status			display the status of a vm"
		puts "list			list all defined boxes"
		puts "listvm			list all virtual machines"
		puts ""
	end

	# list all defined boxes
	def list
		puts "Boxes:"
		@boxes.each do |key, info|
			puts "#{key}		#{info["description"]}"
		end
	end

	# list all virtual machines
	def listvms
		puts "Virtual Machines:"
		%x(vboxmanage list vms).split(/\n/).each do |line|
			puts line.split(/\"/)[1]
		end
	end

	# start a virtual machine
	def start
		raise "Undefined <box>." if @box_def == nil
		puts "Starting VirtualBox VM: #{@vm_name}"
		exec("VBoxManage startvm #{@vm_name} --type headless")
	end

	# stop a virtual machine
	def stop
		raise "Undefined <box>." if @box_def == nil
		puts "Stopping VirtualBox VM: #{@vm_name}"
		exec("VBoxManage controlvm #{@vm_name} poweroff")
	end

	# ssh into a virtual machine
	def ssh
		raise "Undefined <box>." if @box_def == nil
		exec("ssh #{@ssh_name}")
	end

	# tunnel a port on a vm to the local host
	def tunnel(param)
		raise "Undefined <box>." if @box_def == nil
		if param.to_i == 0 && param != "close"
			raise "Tunnel port invalid."
		end
		tunnels = _get_tunnels(@ssh_name)
		tunnels.each do |tunnel|
			if tunnel[:host] == @ssh_name && tunnel[:port] == param
				raise "Tunnel already exists."
			elsif param == "close"
				%x(kill #{tunnel[:pid]})
			end
		end
		if param == "close"
			puts "Closing all tunnels for #{@vm_name}."
			exit
		end
		puts "Creating tunnel on port #{param} from #{@vm_name} to localhost."
		exec("ssh -N #{@ssh_name} -L #{param}/localhost/#{param} 2>&1 </dev/null &")
	end

	# display the status of a virtual machine
	def status
		raise "Undefined <box>." if @box_def == nil
		print @vm_name + " "
		puts _get_active ? "Running" : "Not Running"
		tunnels = _get_tunnels
		if tunnels.size != 0
			print "Tunnels: "
			tunnels.each_with_index do |tunnel, index|
				print tunnel[:port]
				print (index < tunnels.size - 1) ? ", " : "\n"
			end
		end
	end

	# mount a defined vm volume to the local host
	def mount(volume=nil)
		raise "Undefined <box>." if @box_def == nil
		volume, volume_path = _get_volume(volume)
		mount_path = "/Volumes/" + @ssh_name + "_" + volume + "/"

		if %x(mount | grep "on #{mount_path}") != ""
			raise "Volume already mounted at #{mount_path}."
		end

		puts "Mounting #{volume_path} to #{mount_path}"
		if !File.directory?(mount_path)
			Dir.mkdir(mount_path)
		end
		exec("sshfs #{@ssh_name}:#{volume_path} #{mount_path}")
	end

	# unmount a virtual machine volume
	def umount(volume=nil)
		raise "Undefined <box>." if @box_def == nil
		volume, volume_path = _get_volume(volume)
		mount_path = "/Volumes/" + @ssh_name + "_" + volume + "/"

		if %x(mount | grep "on #{mount_path} | grep -v grep") != ""
			if File.directory?(mount_path)
				Dir.rmdir(mount_path)
			end
			raise "Volume mount not found at #{mount_path}."
		else
			puts "Unmounting #{mount_path}"
			exec("umount #{mount_path}")
		end
	end

	private
	def _set_box(box)
		return if box == nil
		if !@boxes.has_key? box
			raise "Unrecognized box index. Definition not found for \"#{box}\"."
		end
		@box_def = @boxes[box]
		@ssh_name = @box_def["ssh_name"] if @box_def.has_key? "ssh_name"
		@vm_name = @box_def["vm_name"] if @box_def.has_key? "vm_name"
	end

	def _get_volume(volume)
		if !@box_def.has_key? "volumes" || @box_def["volumes"].length == 0
			raise "Volume definitions not found. You must first define a volume."
		end

		if volume == nil
			volume = @box_def["volumes"].keys[0]
			volume_path = @box_def["volumes"][volume]
		elsif @box_def["volumes"].has_key? volume
			volume_path = @box_def["volumes"][volume]
		else
			raise "Mount volume undefined. Please specify a defined volume."
		end
		return volume, volume_path
	end

	def _get_active
		running = %x(vboxmanage list runningvms | grep #{@vm_name} | grep -v grep)
		return running != ""
	end

	def _get_tunnels(ssh_name=nil)
		if ssh_name == nil && @box_def != nil
			ssh_name = @ssh_name
		end
		if ssh_name != nil
			procs = %x(ps aux | grep -v grep | grep #{ssh_name})
		else
			procs = %x(ps aux | grep -v grep | grep "ssh -N")
		end
		lines = procs.split /\n/
		tunnels = Array.new
		lines.each do |line|
			words = line.gsub(/\s+/, " ").split(/\s/)
			port = words[14].split(/\//)[2]
			tunnels.push({:host => words[12], :pid => words[1], :port => port})
		end
		return tunnels
	end
end

VBoxer.new(ARGV[0], ARGV[1], ARGV[2])
